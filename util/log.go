package util

import "log"

var flagEnableTrace bool = false

func EnableTrace() {
	flagEnableTrace = true
}

func DisableTrace() {
	flagEnableTrace = false
}

func IsTraceEnabled() bool {
	return flagEnableTrace
}

func doTrace(format string, v ...interface{}) {
	log.Printf(format, v...)
}

func TraceN(format string, v ...interface{}) {
	if flagEnableTrace {
		doTrace(format, v...)
	}
}

func Trace0(format string) {
	if flagEnableTrace {
		doTrace(format)
	}
}

/*
	TraceK functions written below are generated by the following Ruby script:

		def foo(i)
		  args = i.times.map { |k| "v#{k}" }.join(", ")
		  puts "func Trace#{i}(format string, #{args} interface{}) {"
		  puts "\tif flagEnableTrace {"
		  puts "\t\tdoTrace(format, #{args})"
		  puts "\t}"
		  puts "}"
		end
		(1...10).each { |i| foo(i); puts "\n" }
*/

func Trace1(format string, v0 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0)
	}
}

func Trace2(format string, v0, v1 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1)
	}
}

func Trace3(format string, v0, v1, v2 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1, v2)
	}
}

func Trace4(format string, v0, v1, v2, v3 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1, v2, v3)
	}
}

func Trace5(format string, v0, v1, v2, v3, v4 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1, v2, v3, v4)
	}
}

func Trace6(format string, v0, v1, v2, v3, v4, v5 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1, v2, v3, v4, v5)
	}
}

func Trace7(format string, v0, v1, v2, v3, v4, v5, v6 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1, v2, v3, v4, v5, v6)
	}
}

func Trace8(format string, v0, v1, v2, v3, v4, v5, v6, v7 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1, v2, v3, v4, v5, v6, v7)
	}
}

func Trace9(format string, v0, v1, v2, v3, v4, v5, v6, v7, v8 interface{}) {
	if flagEnableTrace {
		doTrace(format, v0, v1, v2, v3, v4, v5, v6, v7, v8)
	}
}
