// +build ENABLE_TRACE

package util

import "log"

func TraceN(format string, v ...interface{}) {
	log.Printf(format, v...)
}

/*
	TraceK functions written below are generated by the following Ruby script:

		def foo(i)
		  args = i.times.map { |k| "v#{k}" }.join(", ")
		  if i == 0
			puts "func Trace0(format string) {"
		  else
			puts "func Trace#{i}(format string, #{args} interface{}) {"
		  end
		  puts "\tTraceN(format, #{args})"
		  puts "}"
		end
		(0...10).each { |i| foo(i); puts "\n" }
*/

func Trace0(format string) {
	TraceN(format)
}

func Trace1(format string, v0 interface{}) {
	TraceN(format, v0)
}

func Trace2(format string, v0, v1 interface{}) {
	TraceN(format, v0, v1)
}

func Trace3(format string, v0, v1, v2 interface{}) {
	TraceN(format, v0, v1, v2)
}

func Trace4(format string, v0, v1, v2, v3 interface{}) {
	TraceN(format, v0, v1, v2, v3)
}

func Trace5(format string, v0, v1, v2, v3, v4 interface{}) {
	TraceN(format, v0, v1, v2, v3, v4)
}

func Trace6(format string, v0, v1, v2, v3, v4, v5 interface{}) {
	TraceN(format, v0, v1, v2, v3, v4, v5)
}

func Trace7(format string, v0, v1, v2, v3, v4, v5, v6 interface{}) {
	TraceN(format, v0, v1, v2, v3, v4, v5, v6)
}

func Trace8(format string, v0, v1, v2, v3, v4, v5, v6, v7 interface{}) {
	TraceN(format, v0, v1, v2, v3, v4, v5, v6, v7)
}

func Trace9(format string, v0, v1, v2, v3, v4, v5, v6, v7, v8 interface{}) {
	TraceN(format, v0, v1, v2, v3, v4, v5, v6, v7, v8)
}
